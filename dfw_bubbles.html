
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DFW Locations — Bubble Map (v2)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body, #map { height: 100%; margin: 0; }
  .legend {
    background: white; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px;
    line-height: 1.3; box-shadow: 0 1px 3px rgba(0,0,0,0.2); font-family: system-ui, Arial, sans-serif;
  }
  .legend h4 { margin: 0 0 6px; font-size: 13px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 12px; }
  .legend-swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #333; }
  .leaflet-popup-content { font: 13px/1.3 system-ui, Arial, sans-serif; }
  .note { color: #a33; font-weight: 600; }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const chainColors = {
  "LC": "#808080",   // Gray
  "MED": "#003f7f",  // Darker blue
  "MEL": "#FFD700",  // Yellow
  "SO": "#FF8C00",   // Orange
  "VS": "#228B22",   // Green
  "VW": "#DC143C",   // Red
  "WP": "#6CA0DC"    // Lighter blue
};

const MIN_RADIUS = 6;
const MAX_RADIUS = 28;

function parseNumber(val) {
  if (val == null) return NaN;
  if (typeof val === 'number') return val;
  const s = String(val).replace(/[^0-9.\-]/g, '');
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : NaN;
}

function getChainCode(p) {
  const CODES = ["LC","MED","MEL","SO","VS","VW","WP"];
  const candidates = [
    p.chain,
    p._file,
    p['chain'],
    p['merged_Company/Business Name'],
    p['Company/Business Name']
  ];
  for (let c of candidates) {
    if (!c) continue;
    const s = String(c).trim().toUpperCase();
    // exact
    if (CODES.includes(s)) return s;
    // contains (e.g., "Store - LC")
    for (const code of CODES) {
      if (s.includes(code)) return code;
    }
  }
  return null;
}

const map = L.map('map', { center: [32.9, -97.0], zoom: 9 });

const streets = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors © CARTO', maxZoom: 19
}).addTo(map);

const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles © Esri — Sources: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, GIS User Community',
  maxZoom: 19
});

L.control.layers({ "Streets": streets, "Satellite": satellite }, {}, { collapsed: true }).addTo(map);

const legend = L.control({position: 'topright'});
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = '<h4>Chains</h4>' +
    Object.entries(chainColors).map(([k, v]) => (
      `<div class="legend-item"><span class="legend-swatch" style="background:${v}"></span>${k}</div>`
    )).join('');
  return div;
};
legend.addTo(map);

// Load GeoJSON, precompute max sales, then draw with normalized sqrt scaling
fetch('vectors.geojson')
  .then(r => r.json())
  .then(geojson => {
    const feats = Array.isArray(geojson.features) ? geojson.features : [];
    // Collect sales values
    const salesVals = feats.map(f => {
      const p = f.properties || {};
      // Prefer numeric field, fallback to formatted string
      return parseNumber(p['Sales Vol_num']) || parseNumber(p['Sales Vol']) || parseNumber(p['merged_Sales Volume']);
    }).filter(v => Number.isFinite(v) && v > 0);

    const maxSales = salesVals.length ? Math.max(...salesVals) : NaN;

    function radiusFromSales(val) {
      const v = parseNumber(val);
      if (!Number.isFinite(v) || v <= 0 || !Number.isFinite(maxSales) || maxSales <= 0) return MIN_RADIUS;
      const r = Math.sqrt(v) / Math.sqrt(maxSales); // 0..1
      return MIN_RADIUS + r * (MAX_RADIUS - MIN_RADIUS);
    }

    const layer = L.geoJSON(geojson, {
      pointToLayer: function(feature, latlng) {
        const p = feature.properties || {};
        const chain = getChainCode(p);
        const color = chainColors[chain] || '#666666';

        const salesNum = parseNumber(p['Sales Vol_num']) || parseNumber(p['Sales Vol']) || parseNumber(p['merged_Sales Volume']);
        const radius = radiusFromSales(salesNum);

        return L.circleMarker(latlng, {
          radius: radius,
          color: '#222',
          weight: 1,
          fillColor: color,
          fillOpacity: 0.85
        });
      },
      onEachFeature: function(feature, layer) {
        const p = feature.properties || {};
        const chainCode = getChainCode(p) || '—';
        const chainLabel = p['merged_Company/Business Name'] || chainCode || 'N/A';
        const addr = p['address_geocoded'] || p['Address'] || 'Address not provided';
        const salesNum = parseNumber(p['Sales Vol_num']) || parseNumber(p['Sales Vol']) || parseNumber(p['merged_Sales Volume']);
        const salesStr = p['merged_Sales Volume'] || (Number.isFinite(salesNum) ? salesNum.toLocaleString() : '');
        const hasSales = Number.isFinite(salesNum) && salesNum > 0;

        const popupHtml = `
          <div>
            <div><strong>Location:</strong> ${addr}</div>
            <div><strong>Chain:</strong> ${chainLabel} (${chainCode})</div>
            <div><strong>Sales:</strong> ${hasSales ? salesStr : '<span class="note">Sales data not available</span>'}</div>
          </div>
        `;
        layer.bindPopup(popupHtml);
        layer.bindTooltip(chainCode, {direction: 'top'});
      }
    }).addTo(map);

    try { map.fitBounds(layer.getBounds().pad(0.15)); } catch (e) {}
  })
  .catch(err => {
    console.error('Failed to load vectors.geojson:', err);
    alert('Could not load vectors.geojson. Make sure it is in the same folder as this HTML file.');
  });
</script>
</body>
</html>
