
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DFW Locations — Bubble Map (v3)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body, #map { height: 100%; margin: 0; }
  .legend {
    background: white; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px;
    line-height: 1.3; box-shadow: 0 1px 3px rgba(0,0,0,0.2); font-family: system-ui, Arial, sans-serif;
  }
  .legend h4 { margin: 0 0 6px; font-size: 13px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 12px; }
  .legend-swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #333; }
  .leaflet-popup-content { font: 13px/1.3 system-ui, Arial, sans-serif; }
  .note { color: #a33; font-weight: 600; }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const chainColors = {
  "LC": "#808080",   // Gray
  "MED": "#003f7f",  // Darker blue
  "MEL": "#FFD700",  // Yellow
  "SO": "#FF8C00",   // Orange
  "VS": "#228B22",   // Green
  "VW": "#DC143C",   // Red
  "WP": "#6CA0DC"    // Lighter blue
};

const MIN_RADIUS = 6;
const MAX_RADIUS = 28;
const CHAIN_CODES = Object.keys(chainColors);

function normalizeKey(k){ return String(k || '').trim().toLowerCase(); }

function parseNumber(val) {
  if (val == null) return NaN;
  if (typeof val === 'number') return val;
  // keep digits, minus, dot, and comma; then remove thousands separators
  let s = String(val);
  // Replace common currency and spaces
  s = s.replace(/\s+/g,'').replace(/[\$€£R\$]/g,'');
  // Handle comma thousands and possible decimal: remove commas if they look like thousands
  // e.g., "1,234,567.89" -> "1234567.89"
  s = s.replace(/,(?=\d{3}(\D|$))/g, '');
  // Replace remaining commas with dots (in case of "123,45")
  if (s.indexOf('.') === -1 && s.indexOf(',') > -1) {
    s = s.replace(/,/g, '.');
  } else {
    s = s.replace(/,/g, '');
  }
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : NaN;
}

function findProp(p, candidates) {
  // Try exact keys first, then case-insensitive by normalized key
  // Finally try fuzzy contains for keys with slashes/spaces variants
  const map = {};
  for (const [k,v] of Object.entries(p)) map[normalizeKey(k)] = v;

  for (const k of candidates) {
    if (k in p) return p[k];
  }
  for (const k of candidates) {
    const nk = normalizeKey(k);
    if (nk in map) return map[nk];
  }
  // fuzzy: try to match by substring of the normalized key
  for (const [k,v] of Object.entries(p)) {
    const nk = normalizeKey(k);
    if (candidates.some(c => nk.includes(normalizeKey(c)))) return v;
  }
  return undefined;
}

function getChainCode(p) {
  const candidates = [
    'chain', '_file',
    'merged_Company/Business Name', 'Company/Business Name',
    'merged_company/business name', 'company/business name'
  ];
  let val = findProp(p, candidates);
  if (val) {
    const s = String(val).trim().toUpperCase();
    if (CHAIN_CODES.includes(s)) return s;
    for (const code of CHAIN_CODES) {
      if (s.includes(code)) return code;
    }
  }
  // last resort: scan any property value to see if equals a chain code
  for (const v of Object.values(p)) {
    const s = String(v || '').toUpperCase();
    if (CHAIN_CODES.includes(s)) return s;
    for (const code of CHAIN_CODES) {
      if (s.includes(code)) return code;
    }
  }
  return null;
}

function getChainLabel(p, chainCode) {
  const lab = findProp(p, ['merged_Company/Business Name', 'Company/Business Name', 'company', 'business name']);
  if (lab) return lab;
  return chainCode || 'N/A';
}

function getSalesNumber(p) {
  // common numeric keys
  const numericCandidates = [
    'Sales Vol_num', 'Sales Vol', 'sales vol_num', 'sales vol',
    'Sales Volume Num', 'sales volume num', 'SalesVolumeNum'
  ];
  let v = findProp(p, numericCandidates);
  if (v !== undefined) {
    const n = parseNumber(v);
    if (Number.isFinite(n)) return n;
  }
  // fallback to formatted string fields (e.g., "$1,135,000")
  const stringCandidates = ['merged_Sales Volume', 'Sales Volume', 'sales volume'];
  v = findProp(p, stringCandidates);
  if (v !== undefined) {
    const n = parseNumber(v);
    if (Number.isFinite(n)) return n;
  }
  return NaN;
}

function getAddress(p) {
  return findProp(p, ['address_geocoded', 'Address', 'address', 'endereco']) || 'Address not provided';
}

function computeMaxSales(features) {
  let maxV = 0;
  for (const f of features) {
    const p = f.properties || {};
    const n = getSalesNumber(p);
    if (Number.isFinite(n) && n > maxV) maxV = n;
  }
  return maxV > 0 ? maxV : NaN;
}

function radiusFromSales(val, maxSales) {
  if (!Number.isFinite(val) || val <= 0 || !Number.isFinite(maxSales) || maxSales <= 0) return MIN_RADIUS;
  const r = Math.sqrt(val) / Math.sqrt(maxSales); // 0..1
  return MIN_RADIUS + r * (MAX_RADIUS - MIN_RADIUS);
}

const map = L.map('map', { center: [32.9, -97.0], zoom: 9 });

const streets = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors © CARTO', maxZoom: 19
}).addTo(map);

const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles © Esri — Sources: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, GIS User Community',
  maxZoom: 19
});

L.control.layers({ "Streets": streets, "Satellite": satellite }, {}, { collapsed: true }).addTo(map);

const legend = L.control({position: 'topright'});
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = '<h4>Chains</h4>' +
    Object.entries(chainColors).map(([k, v]) => (
      `<div class="legend-item"><span class="legend-swatch" style="background:${v}"></span>${k}</div>`
    )).join('');
  return div;
};
legend.addTo(map);

fetch('vectors.geojson')
  .then(r => r.json())
  .then(geojson => {
    const feats = Array.isArray(geojson.features) ? geojson.features : [];
    const maxSales = computeMaxSales(feats);

    const layer = L.geoJSON(geojson, {
      pointToLayer: function(feature, latlng) {
        const p = feature.properties || {};
        const chain = getChainCode(p);
        const color = chainColors[chain] || '#666666';
        const salesNum = getSalesNumber(p);
        const radius = radiusFromSales(salesNum, maxSales);

        return L.circleMarker(latlng, {
          radius: radius,
          color: '#222',
          weight: 1,
          fillColor: color,
          fillOpacity: 0.85
        });
      },
      onEachFeature: function(feature, layer) {
        const p = feature.properties || {};
        const chainCode = getChainCode(p) || '—';
        const chainLabel = getChainLabel(p, chainCode);
        const addr = getAddress(p);
        const salesNum = getSalesNumber(p);
        const hasSales = Number.isFinite(salesNum) && salesNum > 0;
        // Prefer formatted field for display if present
        const salesStrRaw = findProp(p, ['merged_Sales Volume', 'Sales Volume', 'sales volume']);
        const salesStr = salesStrRaw ? String(salesStrRaw) : (hasSales ? salesNum.toLocaleString() : '');

        const popupHtml = `
          <div>
            <div><strong>Location:</strong> ${addr}</div>
            <div><strong>Chain:</strong> ${chainLabel} (${chainCode})</div>
            <div><strong>Sales:</strong> ${hasSales ? salesStr : '<span class="note">Sales data not available</span>'}</div>
          </div>
        `;
        layer.bindPopup(popupHtml);
        layer.bindTooltip(chainCode, {direction: 'top'});
      }
    }).addTo(map);

    try { map.fitBounds(layer.getBounds().pad(0.15)); } catch (e) {}
  })
  .catch(err => {
    console.error('Failed to load vectors.geojson:', err);
    alert('Could not load vectors.geojson. Make sure it is in the same folder as this HTML file.');
  });
</script>
</body>
</html>
