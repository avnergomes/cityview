<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DFW Bubble Map - v3 (filters)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body, #map { height: 100%; margin: 0; }
  .legend {
    background: white; padding: 8px 10px; border: 1px solid #ccc; border-radius: 6px;
    line-height: 1.3; box-shadow: 0 1px 3px rgba(0,0,0,0.2); font-family: system-ui, Arial, sans-serif;
  }
  .legend h4 { margin: 0 0 6px; font-size: 13px; }
  .legend-item { display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 12px; }
  .legend-swatch { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #333; }
  .leaflet-popup-content { font: 13px/1.3 system-ui, Arial, sans-serif; }
  .note { color: #a33; font-weight: 600; }

  /* Filter control */
  .chain-filter {
    background: white; padding: 8px; border: 1px solid #ccc; border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2); font-family: system-ui, Arial, sans-serif; font-size: 12px;
    min-width: 180px;
  }
  .chain-filter h4 { margin: 0 0 6px; font-size: 13px; }
  .chain-filter .actions { display: flex; gap: 6px; margin: 6px 0; }
  .chain-filter select { width: 100%; }
</style>
</head>
<body>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// --- COLORS (exact as requested) ---
const chainColors = {
  "LC":  "#808080", // Gray
  "MED": "#003f7f", // darker blue
  "MEL": "#FFD700", // Yellow
  "SO":  "#FF8C00", // Orange
  "PV":  "#228B22", // Green
  "VS":  "#800080", // Purple
  "VW":  "#DC143C", // Red
  "WP":  "#6CA0DC"  // lighter blue
};

const MIN_RADIUS = 3;
const MAX_RADIUS = 50;
const CHAIN_CODES = Object.keys(chainColors);

function normalizeKey(k){ return String(k || '').trim().toLowerCase(); }

function parseNumber(val) {
  if (val == null) return NaN;
  if (typeof val === 'number') return val;
  let s = String(val);
  s = s.replace(/\s+/g,'').replace(/[\$€£R\$]/g,'');
  s = s.replace(/,(?=\d{3}(\D|$))/g, '');
  if (s.indexOf('.') === -1 && s.indexOf(',') > -1) {
    s = s.replace(/,/g, '.');
  } else {
    s = s.replace(/,/g, '');
  }
  const n = parseFloat(s);
  return Number.isFinite(n) ? n : NaN;
}

function findProp(p, candidates) {
  const map = {};
  for (const [k,v] of Object.entries(p)) map[normalizeKey(k)] = v;

  for (const k of candidates) { if (k in p) return p[k]; }
  for (const k of candidates) {
    const nk = normalizeKey(k);
    if (nk in map) return map[nk];
  }
  for (const [k,v] of Object.entries(p)) {
    const nk = normalizeKey(k);
    if (candidates.some(c => nk.includes(normalizeKey(c)))) return v;
  }
  return undefined;
}

function getChainCode(p) {
  const candidates = [
    'chain', '_file',
    'merged_Company/Business Name', 'Company/Business Name',
    'merged_company/business name', 'company/business name'
  ];
  let val = findProp(p, candidates);
  if (val) {
    const s = String(val).trim().toUpperCase();
    if (CHAIN_CODES.includes(s)) return s;
    for (const code of CHAIN_CODES) {
      if (s.includes(code)) return code;
    }
  }
  for (const v of Object.values(p)) {
    const s = String(v || '').toUpperCase();
    if (CHAIN_CODES.includes(s)) return s;
    for (const code of CHAIN_CODES) {
      if (s.includes(code)) return code;
    }
  }
  return null;
}

function getChainLabel(p, chainCode) {
  const lab = findProp(p, ['merged_Company/Business Name', 'Company/Business Name', 'company', 'business name']);
  if (lab) return lab;
  return chainCode || 'N/A';
}

function getSalesNumber(p) {
  const numericCandidates = [
    'Sales Vol_num', 'Sales Vol', 'sales vol_num', 'sales vol',
    'Sales Volume Num', 'sales volume num', 'SalesVolumeNum'
  ];
  let v = findProp(p, numericCandidates);
  if (v !== undefined) {
    const n = parseNumber(v);
    if (Number.isFinite(n)) return n;
  }
  const stringCandidates = ['merged_Sales Volume', 'Sales Volume', 'sales volume'];
  v = findProp(p, stringCandidates);
  if (v !== undefined) {
    const n = parseNumber(v);
    if (Number.isFinite(n)) return n;
  }
  return NaN;
}

function getAddress(p) {
  return findProp(p, ['address_geocoded', 'Address', 'address', 'endereco']) || 'Address not provided';
}

function computeMaxSales(features) {
  let maxV = 0;
  for (const f of features) {
    const p = f.properties || {};
    const n = getSalesNumber(p);
    if (Number.isFinite(n) && n > maxV) maxV = n;
  }
  return maxV > 0 ? maxV : NaN;
}

function radiusFromSales(val, maxSales) {
  if (!Number.isFinite(val) || val <= 0 || !Number.isFinite(maxSales) || maxSales <= 0) return MIN_RADIUS;
  const r = Math.sqrt(val) / Math.sqrt(maxSales); // 0..1
  return MIN_RADIUS + r * (MAX_RADIUS - MIN_RADIUS);
}

// --- MAP ---
const map = L.map('map', { center: [32.9, -97.0], zoom: 9 });

const streets = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors © CARTO', maxZoom: 19
}).addTo(map);

const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles © Esri — Sources: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, GIS User Community',
  maxZoom: 19
});

L.control.layers({ "Streets": streets, "Satellite": satellite }, {}, { collapsed: true }).addTo(map);

// --- LEGEND ---
const legend = L.control({position: 'topright'});
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = '<h4>Chains</h4>' +
    Object.entries(chainColors).map(([k, v]) =>
      `<div class="legend-item"><span class="legend-swatch" style="background:${v}"></span>${k}</div>`
    ).join('');
  return div;
};
legend.addTo(map);

// --- FILTER CONTROL (multi-select dropdown) ---
let chainFilterControl;
let selectedChains = new Set(CHAIN_CODES); // start with all selected

function buildFilterControl() {
  chainFilterControl = L.control({ position: 'topleft' });
  chainFilterControl.onAdd = function() {
    const div = L.DomUtil.create('div', 'chain-filter');
    div.innerHTML = `
      <h4>Filter chains</h4>
      <div class="actions">
        <button type="button" id="cf-select-all">Select all</button>
        <button type="button" id="cf-clear">Clear</button>
      </div>
      <select id="cf-select" multiple size="${Math.min(8, CHAIN_CODES.length)}" aria-label="Chains">
        ${CHAIN_CODES.map(c => `<option value="${c}" selected>${c}</option>`).join('')}
      </select>
    `;
    // Prevent map drag when interacting
    L.DomEvent.disableClickPropagation(div);
    return div;
  };
  chainFilterControl.addTo(map);

  const selectEl = document.getElementById('cf-select');
  const btnAll = document.getElementById('cf-select-all');
  const btnClear = document.getElementById('cf-clear');

  function syncSelectedFromUI() {
    selectedChains = new Set(Array.from(selectEl.selectedOptions).map(o => o.value));
    applyChainFilter();
  }
  selectEl.addEventListener('change', syncSelectedFromUI);

  btnAll.addEventListener('click', () => {
    for (const opt of selectEl.options) opt.selected = true;
    syncSelectedFromUI();
  });
  btnClear.addEventListener('click', () => {
    for (const opt of selectEl.options) opt.selected = false;
    syncSelectedFromUI();
  });
}

buildFilterControl();

// --- DATA LAYER & FILTERING ---
let pointsLayer = null;

function applyChainFilter() {
  if (!pointsLayer) return;
  pointsLayer.eachLayer(layer => {
    const chain = layer.feature?.properties?._chain_code || null;
    const show = chain && selectedChains.has(chain);
    if (show) {
      layer.addTo(pointsLayer); // ensure attached
      layer.setStyle({ opacity: 1, fillOpacity: 0.85 });
    } else {
      // hide by making it fully transparent and removing from renderer
      pointsLayer.removeLayer(layer);
    }
  });

  // If everything hidden, skip fitBounds to avoid errors
  try {
    const b = pointsLayer.getBounds();
    if (b.isValid()) map.fitBounds(b.pad(0.15));
  } catch (e) {}
}

fetch('vectors.geojson')
  .then(r => r.json())
  .then(geojson => {
    const feats = Array.isArray(geojson.features) ? geojson.features : [];
    const maxSales = computeMaxSales(feats);

    // Precompute and store chain code on properties for fast filtering
    for (const f of feats) {
      const p = f.properties || (f.properties = {});
      p._chain_code = getChainCode(p); // may be null
    }

    pointsLayer = L.geoJSON({ type: 'FeatureCollection', features: feats }, {
      pointToLayer: function(feature, latlng) {
        const p = feature.properties || {};
        const chain = p._chain_code;
        const color = chainColors[chain] || '#666666';
        const salesNum = getSalesNumber(p);
        const radius = radiusFromSales(salesNum, maxSales);

        return L.circleMarker(latlng, {
          radius: radius,
          color: '#222',
          weight: 1,
          fillColor: color,
          fillOpacity: 0.85
        });
      },
      onEachFeature: function(feature, layer) {
        const p = feature.properties || {};
        const chainCode = p._chain_code || '—';
        const chainLabel = getChainLabel(p, chainCode);
        const addr = getAddress(p);
        const salesNum = getSalesNumber(p);
        const hasSales = Number.isFinite(salesNum) && salesNum > 0;
        const salesStrRaw = findProp(p, ['merged_Sales Volume', 'Sales Volume', 'sales volume']);
        const salesStr = salesStrRaw ? String(salesStrRaw) : (hasSales ? salesNum.toLocaleString() : '');

        const popupHtml = `
          <div>
            <div><strong>Location:</strong> ${addr}</div>
            <div><strong>Chain:</strong> ${chainLabel} (${chainCode})</div>
            <div><strong>Sales:</strong> ${hasSales ? salesStr : '<span class="note">Sales data not available</span>'}</div>
          </div>
        `;
        layer.bindPopup(popupHtml);
        layer.bindTooltip(chainCode, {direction: 'top'});
      }
    }).addTo(map);

    // Initial filter application (all selected)
    applyChainFilter();

    // Fit once on load
    try {
      const b = pointsLayer.getBounds();
      if (b.isValid()) map.fitBounds(b.pad(0.15));
    } catch (e) {}
  })
  .catch(err => {
    console.error('Failed to load vectors.geojson:', err);
    alert('Could not load vectors.geojson. Make sure it is in the same folder as this HTML file.');
  });
</script>
</body>
</html>
